-----------
[10.18]

1. @Transactional = commit을 자동 실행, 예외 발생시 자동 Rollback 시켜줌.

2. @EnableWebMvc 어노테이션을 사용하면 Spring Framework에서 자동으로 config값을 세팅함.


-----------
[10.19]

1. 엔티티의 생명주기

- 비영속 : 영속성 컨텍스트와 관계가 없는 상태              // Member member = new Member();
- 영속 : 영속성 컨텍스트에 저장된 상태                        // em.persist(member);
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

.find는 영속성을 가진다.

Dept dept = em.find(Dept.class, 10); // find = select, Dept 테이블 내에 값 10을 찾는다.
        dept.setDname("서울"); // 값이 10인 행(레코드)의 Dname을 서울로 변경.

------------
[10.22]

인증 (Authentication) : 사용자의 아이디/패스워드를 증명하는 절차

인가 (Authorization) : 사용자의 권한이 적절한가에 대한 승인 과정 (허가) 


-------------
[10.23]

＊ 객체의 연관관계 : 단방향 관계 (테이블 연관관계 : 양방향)
＊ 데이터베이스 테이블은 외래키 하나로 양방향 조회 가능.
＊ 객체는 양방향 연관 관계라는 것이 없다.

<객체의 연관관계>
＊ 단방향 매핑만으로 매핑완료.
＊ 양방향 매핑은 객체 그래프 탐색 기능 추가

-------------
[10.25]

CSRF : Cross Site Request Forgery(사이트 간 요청 위조)의 줄임말로 웹 취약점 중 하나.
＊ 공격자가 희생자의 권한을 도용하여 특정 웹 사이트의 기능을 실행

세미나같은 발표 노하우 :
＊ 완전히 알고 있는 것, 완전히 알지 못하는 것 분리
＊ 완전히 알고 있는 건 분명히 말하기, 잘 모르는 건 추정하는 식으로. ex) ??? 으로 추정됩니다.
＊ 거짓말 X

---------------
[10.28]

자기소개서, 포트폴리오, 이력서 등 한번만 쓰지 말고 취업 후에도 계속 업데이트를 권장.

validation :
＊ 잘못된 값 입력을 막는 것 
＊ 사용자가 서비스를 제대로 이용하게 끔 유도

validationUtils :
＊ validationUtils 클래스는 객체의 값 검증 코드를 간결하게 작성할 수 있도록 도와준다

required=필수항목입니다.
required.email=이메일은 필수입니다.

그냥 에러코드 보다 에러코드 + "." 필드명이 우선 순위라서 required보다 먼저 나오게 된다. 
(required.email이 required보다 우선) // 책 338p 참고

----------------
[10.30]

필터 : 특정 작업(로깅, 인증, 인가, 데이터 변환 등)의 요청 및 응답을 가로챔
인터셉터 : 특정 URI로 요청했을 때 컨트롤러로 가는 요청을 가로챔

시큐리티 : 필터 + 인터셉터 등의 복잡한 기능
spring security : 인증, 권한, 보안 기능을 제공하는 Spring의 하위 프레임워크

-----------------
[10.31]

스프링 부트의 이벤트 흐름 순서 ex) 주문, 결제 시스템

＊ 먼저 컨트롤러가 클라이언트(사용자)의 요청을 받는다. (주문 생성, 재고 확인, 결제 처리 등등)

＊ 주문이 생성되었다면 퍼블리셔가 특정 이벤트를 발행한다. (OrderCreateEvent 같은)
 - 이때 퍼블리셔가 주문이 완료됐다는 이벤트를 만들어서 시스템에 알리는 것.

＊ 이벤트가 발행되었다면 리스너가 이 이벤트를 감지해서 리스너 내에 코드가 실행되어
 이벤트에 해당하는 필요한 로직이 작동한다.

＊ 처리가 완료되면 클라이언트가 요청한 작업의 결과를 컨트롤러를 거쳐서 보내준다.
 - ex) 메시지를 띄어서 주문이 완료됨, 재고 부족함, 주문 확인 페이지로 리다이렉션 등.



기초 정리

예시
[컨트롤러]

private final CustomEventPublisher customEventPublisher;

@GetMapping("/event/{msg}")
    public void event(@PathVariable Order msg)

＊ 사용자가 주소창에 값을 입력하면 그 값이 msg에 전달된다. (@PathVariable인 경우 주소창에서 전달됨) 

＊ 입력된 값이 Order 객체로 변환되어 msg라는 매개변수에 저장된다

＊ 이 매개변수를 가지고 다양한 로직을 만들 수 있다.
 - 주문 정보를 가지고 생성 로직을 수행, 재고가 없어서 주문을 취소시키는 로직, 결제 로직 실행 등


 @GetMapping("/event/{msg}")
    public void event(@PathVariable Order msg) {
        
        // 주문 메시지를 퍼블리셔에 전달하여 이벤트 발행
        customEventPublisher.doStuffAndPublishAnEvent(msg);
    }

＊ 주문 정보를 msg라는 매개변수가 가지고 있고 이걸 customEventPublisher라는 클래스에 있는
 doStuffAndPublishAnEvent라는 메서드가 msg를 이용해서 코드를 실행한다. (퍼블리셔이므로 이벤트를 발행한다.)

＊ customEventPublisher 클래스를 사용하기 위해서는 컨트롤러 클래스 안에 CustomEventPublisher customEventPublisher; 라는 코드 선언이 필요하다. (public 이든 private 이든)

-----------------------------

[11.12 챗GPT ]

드디어 해결됐다니 정말 기쁩니다! 🎉

왜 처음에 문제가 있었는지 간단히 요약해볼게요:

1. 암호화된 비밀번호 비교 문제
처음에 Member 클래스에서 비밀번호를 평문으로 비교하려고 했습니다.
그러나 Spring Security에서는 비밀번호가 암호화되어 저장되기 때문에 평문으로 비교하면 항상 실패합니다.
**PasswordEncoder**를 사용해야 기존 비밀번호를 암호화된 상태로 비교할 수 있고, 새 비밀번호도 암호화하여 저장할 수 있습니다.
2. changePassword 메소드에서 PasswordEncoder 누락
Member 클래스의 changePassword 메소드에서 비밀번호를 바꾸는 로직이 있었지만, **암호화된 비밀번호를 처리할 PasswordEncoder**가 누락되어 있었습니다.
이로 인해, 평문 비밀번호와 암호화된 비밀번호를 비교하려 했고, 비밀번호 비교가 제대로 이루어지지 않았습니다.
3. changePassword 호출 시 인수 문제
PasswordEncoder를 사용하려면 changePassword 메소드에서 PasswordEncoder를 받아서 사용해야 했습니다.
처음에는 이 부분이 제대로 처리되지 않아서 oldPwd, newPwd를 그대로 넘기기만 하고, 비밀번호 검증을 위한 암호화된 비교를 하지 않았습니다.
4. Spring Security와 PasswordEncoder의 올바른 사용
Spring Security에서는 PasswordEncoder를 이용해 비밀번호를 암호화하고, 비밀번호를 비교할 때 암호화된 비밀번호를 사용하는 방식입니다. 이를 이용해야 비밀번호 변경을 안전하게 처리할 수 있습니다.
**BCryptPasswordEncoder**를 사용해서 비밀번호를 암호화한 후 비교할 수 있도록 했습니다.
해결된 부분:
암호화된 비밀번호 비교를 위해 PasswordEncoder를 사용하고,
비밀번호 변경 시 암호화된 새 비밀번호를 저장할 수 있도록 수정했습니다.
결론
처음에는 암호화된 비밀번호를 처리할 로직이 빠졌고, 이를 제대로 처리하려면 PasswordEncoder를 사용해야 했습니다. 이제 그 부분을 수정하여, 암호화된 비밀번호를 안전하게 처리할 수 있게 되었고, 비밀번호 변경이 정상적으로 작동하게 된 것입니다!

문제를 해결하는 과정에서 많은 학습이 있었겠죠? 이제 비밀번호 변경 로직이 안전하고 제대로 작동하게 되었으니, 다른 부분들도 잘 작동할 거라 믿습니다. 😊

궁금한 점이 더 있거나, 다른 부분에서 어려움이 있으면 언제든지 도와드릴게요!

--------------------
[11.18]

DTO는 임시 저장공간. 클라이언트와 서버의 데이터 전달을 위한 객체


-------------------
[11.28]

회사 면접 볼때 Q&A 시간에 기업에 대해 물어보는 것이 중요. 기업 조사를 하고 가야 함.


기업에서 
1. 개발자 직무를 선택한 이유

2. 어떤 노력과 경험

3. 회사를 선택한 이유


이력서(두괄식) 작성법

기업에 들어감으로써 자신의 가치를 올리는 포부나 동기도 좋지만 이 직무로 인해
기업에 성취하고자 하는 본인의 목표 

입사 후 포부는 기본안 작성후 수정하지 않아도 괜찮다.

기술적 질문이 들어와서 대답을 못하는 것보다 대안을 제시하는 것이 좋다.
(파이썬은 잘 모르지만 자바를 배웠기 때문에 충분히 학습할 수 있습니다.)


---------------------------
[12.02]

김희준, 김동현, 김정필, 박두인, 윤상익, 이승진, 이혁진

회의록 (기록 담당자 필요), 개발 계획서 (개발 일정, 기능 구현)



---------------------------
[실시간 채팅방]

저장하고 sb1128 경로로 가서 gradlew build -x test


// git bash를 키고 경로로 이동 후

cd /c/_intellij/sb1128

// 업데이트 한거 ec2에 업로드 하기

scp -i /c/Users/DU/.ssh/ChatKey.pem build/libs/sb1128-0.0.1-SNAPSHOT.jar ec2-user@ec2-3-25-193-174.ap-southeast-2.compute.amazonaws.com:/home/ec2-user/


// 서버 실행하기

ssh -i /c/Users/DU/.ssh/ChatKey.pem ec2-user@ec2-3-25-193-174.ap-southeast-2.compute.amazonaws.com

java -jar sb1128-0.0.1-SNAPSHOT.jar